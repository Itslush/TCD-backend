<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operation: TCD Dashboard - Modern</title>

    <!-- Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <!-- Highlight.js Theme -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <!-- Your Stylesheet -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

</head>
<body>
    <div class="container">
        <h1>Operation TCD status:</h1>
        <p class="subtitle">Real-time statistics from all bots</p>

        <div class="stats-grid">
            <div class="stat-item" id="stat-bots">
                <h2 title="Number of bots currently connected and active.">
                    <i class="fas fa-robot"></i> Bots Online
                </h2>
                <p class="value"><span id="bot-count" class="loading">Loading...</span></p>
            </div>
            <div class="stat-item" id="stat-servers">
                <h2 title="Number of game servers currently reserved or occupied by bots.">
                    <i class="fas fa-server"></i> Servers Occupied
                </h2>
                <p class="value"><span id="server-count" class="loading">Loading...</span></p>
            </div>
            <div class="stat-item" id="stat-flings">
                <h2 title="Total number of 'fling' actions reported by all bots since tracking started.">
                    <i class="fas fa-bullseye"></i> Total Flings Reported
                </h2>
                <p class="value"><span id="total-flings" class="loading">Loading...</span></p>
            </div>
        </div>

        <div class="json-view">
            <div class="json-header">
                <h2><i class="fas fa-code"></i> Live Server Reservations</h2>
                <div class="json-controls">
                    <button id="copy-json" class="control-btn copy-btn" title="Copy JSON to clipboard">
                        <i class="far fa-copy"></i> Copy
                    </button>
                    <button id="toggle-json" class="control-btn toggle-btn" aria-expanded="true" aria-controls="json-content">
                        Hide
                    </button>
                </div>
            </div>
            <div id="json-content">
                <!-- Pre-wrap ensures long lines wrap if needed, while preserving formatting -->
                <pre><code id="reservations-json" class="language-json loading">Loading reservation data...</code></pre>
            </div>
        </div>

        <p class="last-updated">
            <span class="live-indicator-wrap">
                <span class="live-indicator"></span> Live
            </span>
            Last updated: <span id="last-updated-time">Never</span>
        </p>
    </div>

    <!-- Highlight.js Core & JSON Language -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>

    <!-- Your Script -->
    <script>
        const botCountEl = document.getElementById('bot-count');
    const serverCountEl = document.getElementById('server-count');
    const totalFlingsEl = document.getElementById('total-flings');
    const reservationsJsonEl = document.getElementById('reservations-json');
    const lastUpdatedEl = document.getElementById('last-updated-time');
    const toggleJsonBtn = document.getElementById('toggle-json');
    const jsonContent = document.getElementById('json-content');
    const copyJsonBtn = document.getElementById('copy-json');
    const liveIndicator = document.querySelector('.live-indicator');
    const statItems = {
        bots: document.getElementById('stat-bots'),
        servers: document.getElementById('stat-servers'),
        flings: document.getElementById('stat-flings')
    };

    // --- Constants ---
    const UPDATE_INTERVAL = 7000;

    // --- State ---
    let initialLoadComplete = false;
    let previousJsonString = null; // Store previous JSON to check for changes
    let updateScheduled = false; // Prevent scheduling multiple rAF updates

    // --- Functions ---

    async function updateData() {
        // Don't explicitly set loading state here anymore, let UI update handle it
        console.log("Fetching updated data...");

        try {
            const [statsResponse, reservationsResponse] = await Promise.all([
                fetch('/'),
                fetch('/reservations')
            ]);

            if (!statsResponse.ok) throw new Error(`Stats fetch failed: ${statsResponse.status} ${statsResponse.statusText}`);
            if (!reservationsResponse.ok) throw new Error(`Reservations fetch failed: ${reservationsResponse.status} ${reservationsResponse.statusText}`);

            const statsData = await statsResponse.json();
            const reservationsData = await reservationsResponse.json();

            // Process the update
            processUpdate(statsData, reservationsData);
            setErrorState(null); // Clear previous errors on success
            initialLoadComplete = true;

        } catch (error) {
            console.error("Error fetching data:", error);
            setErrorState(error.message || "Unknown error");
            initialLoadComplete = true; // Mark load complete even on error
        }
    }

    /**
     * Processes the fetched data and schedules UI updates.
     */
    function processUpdate(stats, reservations) {
         // 1. Update simple stats immediately (low cost)
         applyUpdateEffect(botCountEl, stats?.botCount);
         applyUpdateEffect(serverCountEl, stats?.serverCount);
         applyUpdateEffect(totalFlingsEl, stats?.totalFlings);

         // 2. Update timestamp and indicator (low cost)
         if (lastUpdatedEl) lastUpdatedEl.textContent = new Date().toLocaleTimeString();
         if (liveIndicator && !liveIndicator.classList.contains('pulsing')) {
             liveIndicator.classList.add('pulsing');
         }

         // 3. Handle potentially expensive JSON update
         try {
            const currentJsonString = (reservations && typeof reservations === 'object')
                ? JSON.stringify(reservations, null, 2)
                : (reservations ? String(reservations) : null); // Use null for invalid/non-object

            // Only update DOM if JSON changed or if it's invalid/error state
            if (currentJsonString !== previousJsonString || currentJsonString === null) {
                 scheduleJsonUpdate(currentJsonString, reservations); // Pass original data too for type check
                 previousJsonString = currentJsonString; // Update stored string
            } else {
                // If JSON is the same, still ensure loading state is removed if needed
                if (reservationsJsonEl.classList.contains('loading')) {
                     reservationsJsonEl.classList.remove('loading');
                     console.log("JSON unchanged, ensuring loading class removed.");
                }
            }

        } catch (e) {
             console.error("Error stringifying reservations JSON:", e);
             scheduleJsonUpdate(`Error processing JSON: ${e.message}`, null); // Schedule error display
             previousJsonString = null; // Reset previous string on error
        }
    }

     /**
     * Schedules the JSON highlighting and DOM update using requestAnimationFrame.
     * @param {string|null} jsonString - The stringified JSON or error message.
     * @param {object|null} reservationsData - Original reservation data for type check.
     */
     function scheduleJsonUpdate(jsonString, reservationsData) {
        if (updateScheduled) return; // Don't schedule if one is already pending
        updateScheduled = true;

        requestAnimationFrame(() => {
            try {
                if (!jsonString || !reservationsData || typeof reservationsData !== 'object') {
                    // Handle invalid data or errors passed from processUpdate
                    reservationsJsonEl.textContent = jsonString || "Invalid or empty reservation data.";
                    reservationsJsonEl.classList.add('loading'); // Use loading style for error/invalid
                    console.warn("Displaying invalid/error state for reservations.");
                } else if (typeof hljs !== 'undefined' && hljs.highlight) {
                    // Highlight valid JSON
                    const highlightedCode = hljs.highlight(jsonString, { language: 'json' }).value;
                    reservationsJsonEl.innerHTML = highlightedCode;
                    reservationsJsonEl.classList.remove('loading');
                    console.log("JSON highlighting updated via rAF.");
                } else {
                    // Fallback if hljs is missing
                    reservationsJsonEl.textContent = jsonString;
                    reservationsJsonEl.classList.remove('loading');
                    console.warn("highlight.js not ready. Displaying raw JSON via rAF.");
                }
            } catch (e) {
                 // Catch errors during highlighting or innerHTML update
                 console.error("Error during scheduled JSON update:", e);
                 reservationsJsonEl.textContent = `Error updating JSON view: ${e.message}`;
                 reservationsJsonEl.classList.add('loading');
            } finally {
                updateScheduled = false; // Allow next update to be scheduled
            }
        });
     }


    /**
     * Applies an update effect to an element when its value changes. (Minor tweaks)
     */
    function applyUpdateEffect(element, newValue) {
        if (!element) return;

        const isLoading = element.classList.contains('loading');
        const currentValue = isLoading ? null : element.textContent; // Don't compare against loading text
        const newValueStr = String(newValue ?? '?');

        // Always remove loading class when applying new value
        if (isLoading) {
            element.classList.remove('loading');
        }

        // Update text content only if different or was loading
        if (currentValue !== newValueStr) {
            element.textContent = newValueStr;

            // Apply visual 'updated' cue only if value truly changed (not just from loading state)
             if (currentValue !== null && newValueStr !== '?') {
                 element.classList.add('updated');
                 setTimeout(() => {
                     if (element) element.classList.remove('updated');
                 }, 300); // Animation duration
            }
        }
    }

    /**
     * Sets or removes the initial loading state (skeletons). Called only once.
     */
     function setInitialLoadingState() {
        const elements = [botCountEl, serverCountEl, totalFlingsEl, reservationsJsonEl.parentNode]; // Target parent <pre> for code block maybe? No, code itself.
        elements.forEach(el => {
            if (el) {
                el.classList.add('loading');
                 // Set initial text if needed (CSS might handle this better with ::before content)
                 // if(el !== reservationsJsonEl) el.textContent = '...';
                 // else el.textContent = 'Loading data...';
            }
        });
        // Don't start pulsing until first successful update
        if (liveIndicator) liveIndicator.classList.remove('pulsing');
     }

    /**
     * Updates the UI to reflect an error state.
     */
    function setErrorState(errorMessage) {
        const isError = errorMessage !== null;

        Object.values(statItems).forEach(item => item?.classList.toggle('error', isError));

        if (isError) {
            const errorText = `Error`;
            [botCountEl, serverCountEl, totalFlingsEl].forEach(el => {
                if (el) {
                    applyUpdateEffect(el, errorText); // Use apply effect to handle loading class removal too
                    // Ensure loading isn't re-added if applyUpdateEffect didn't change text
                     if(!el.classList.contains('loading') && el.textContent === errorText) {
                         // Maybe add a specific error text style instead of reusing loading
                     }
                }
            });
            // Schedule the error message update for JSON view
            scheduleJsonUpdate(`Failed to load data: ${errorMessage}`, null);
            previousJsonString = null; // Reset comparison string

            if (lastUpdatedEl) lastUpdatedEl.textContent = 'Update Failed';
            if (liveIndicator) liveIndicator.classList.remove('pulsing');
        } else {
             // Clear error state (will be handled by next successful processUpdate)
        }
    }

    // --- Event Listeners --- (Keep existing listeners for toggle/copy)
    toggleJsonBtn.addEventListener('click', () => { /* ... */ });
    copyJsonBtn.addEventListener('click', () => { /* ... */ });


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM fully loaded. Initializing...");
        // Set initial skeleton/loading state visually
        setInitialLoadingState();
        // Initial data fetch
        updateData();
        // Set interval for subsequent updates
        setInterval(updateData, UPDATE_INTERVAL);
    });
    </script>

</body>
</html>